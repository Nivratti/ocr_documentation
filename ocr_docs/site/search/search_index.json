{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 OCR (optical character recognition) is the use of technology to distinguish printed or handwritten text characters inside digital images of physical documents, such as a scanned paper document. The basic process of OCR involves examining the text of a document and translating the characters into code that can be used for data processing. OCR is sometimes also referred to as text recognition. Used OCR Engines: \u00b6 PaddleOCR EasyOCR MMOCR TesseractOCR We have fine-tuned paddleocr and easyocr models. modules: \u00b6 Image Skew correction Image orientation correction Text detection Text recognition Structured data System Flow: \u00b6","title":"Introduction"},{"location":"#introduction","text":"OCR (optical character recognition) is the use of technology to distinguish printed or handwritten text characters inside digital images of physical documents, such as a scanned paper document. The basic process of OCR involves examining the text of a document and translating the characters into code that can be used for data processing. OCR is sometimes also referred to as text recognition.","title":"Introduction"},{"location":"#used-ocr-engines","text":"PaddleOCR EasyOCR MMOCR TesseractOCR We have fine-tuned paddleocr and easyocr models.","title":"Used OCR Engines:"},{"location":"#modules","text":"Image Skew correction Image orientation correction Text detection Text recognition Structured data","title":"modules:"},{"location":"#system-flow","text":"","title":"System Flow:"},{"location":"installation/","text":"Installation \u00b6 A) Server requirements: \u00b6 Hardware: \u00b6 CPU cores(4 plus) RAM (8 GB plus) SSD storage: 100 GB GPU card(atleast 4GB memory) Software: \u00b6 Ubuntu 18 / Ubuntu 20 CUDA 10.2 / CUDA 11.6 with cuda compiler Python3 Sample result after running nvidia-smi command: \u00b6 Sample result after running nvcc --version command: \u00b6 Installation: \u00b6 From pip package: Unzip OCR zipped file, goto main folder, and run pip install -r requirements.txt Docker: Command to build: sudo docker build . -t ocr:latest Run : sudo docker run -p 5000:5000 --gpus all --init -it ocr","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#a-server-requirements","text":"","title":"A) Server requirements:"},{"location":"installation/#hardware","text":"CPU cores(4 plus) RAM (8 GB plus) SSD storage: 100 GB GPU card(atleast 4GB memory)","title":"Hardware:"},{"location":"installation/#software","text":"Ubuntu 18 / Ubuntu 20 CUDA 10.2 / CUDA 11.6 with cuda compiler Python3","title":"Software:"},{"location":"installation/#sample-result-after-running-nvidia-smi-command","text":"","title":"Sample result after running nvidia-smi command:"},{"location":"installation/#sample-result-after-running-nvcc-version-command","text":"","title":"Sample result after running nvcc --version command:"},{"location":"installation/#installation_1","text":"From pip package: Unzip OCR zipped file, goto main folder, and run pip install -r requirements.txt Docker: Command to build: sudo docker build . -t ocr:latest Run : sudo docker run -p 5000:5000 --gpus all --init -it ocr","title":"Installation:"},{"location":"sample/","text":"","title":"Sample"},{"location":"structured_data/","text":"Structured data \u00b6 key information extraction \u00b6 Key information extraction (KIE) refers to extracting key information from text or images. As the downstream task of OCR, KIE of document image has many practical application scenarios, such as form recognition, ticket information extraction, ID card information extraction, etc. However, it is time-consuming and laborious to extract key information from these document images by manpower. It's challengeable but also valuable to combine multi-modal features (visual, layout, text, etc) together and complete KIE tasks. Methods: Text Text + layout Text + layout + Visual 1. Text only methods: \u00b6 Only text content based kie methods such as Named entity recognition will give less accuracy as compare to other methods. 2. Text + layout (We are using this method for English structured data): \u00b6 It combines text and layout features. For text content manipulation we can use regex and fuzzy library, for layout part we can use numpy library to handle the layout i.e coordinates values. This method will be faster and it avoids need of key data labeling and kie model training. Sometimes it may take longer time if ocr result not good and different formats for ID, to adjust. 3. Text + layout + Visual: \u00b6 In this method we train one deep learning based model for key information extraction. We need to train model for each card to give best result and avoid complexity. key value data needs to be annotated to train model. At least 50 card images are required to train kie model to get good result.","title":"Structured data"},{"location":"structured_data/#structured-data","text":"","title":"Structured data"},{"location":"structured_data/#key-information-extraction","text":"Key information extraction (KIE) refers to extracting key information from text or images. As the downstream task of OCR, KIE of document image has many practical application scenarios, such as form recognition, ticket information extraction, ID card information extraction, etc. However, it is time-consuming and laborious to extract key information from these document images by manpower. It's challengeable but also valuable to combine multi-modal features (visual, layout, text, etc) together and complete KIE tasks. Methods: Text Text + layout Text + layout + Visual","title":"key information extraction"},{"location":"structured_data/#1-text-only-methods","text":"Only text content based kie methods such as Named entity recognition will give less accuracy as compare to other methods.","title":"1. Text only methods:"},{"location":"structured_data/#2-text-layout-we-are-using-this-method-for-english-structured-data","text":"It combines text and layout features. For text content manipulation we can use regex and fuzzy library, for layout part we can use numpy library to handle the layout i.e coordinates values. This method will be faster and it avoids need of key data labeling and kie model training. Sometimes it may take longer time if ocr result not good and different formats for ID, to adjust.","title":"2. Text + layout (We are using this method for English structured data):"},{"location":"structured_data/#3-text-layout-visual","text":"In this method we train one deep learning based model for key information extraction. We need to train model for each card to give best result and avoid complexity. key value data needs to be annotated to train model. At least 50 card images are required to train kie model to get good result.","title":"3. Text + layout + Visual:"},{"location":"dataset_preparation/annotation-tool/","text":"For data labeling purpose we have used PPOCRLabel tool . Tool also included in code part. You can either view video tutorial or you can refer doc link for exploring labeling process. Video tutorial link Splitting dataset: \u00b6 Once you are ready with annotations you can export label and recognition result, that we need to split into train, validation and test set for ocr training or fine-tuning. You can use modified gen_ocr_train_val_test.py file to split dataset,that will contains relative filepath in label file, so we can use that file for training on new system easily. download code file gen_ocr_train_val_test.py \"\"\" Usage: python gen_ocr_train_val_test.py --trainValTestRatio \"8:1:1\" --datasetRootPath \"/Philippines-ids/driving-license/\" --detRootPath \"../train_data/det_phl_driving_license\" --recRootPath \"../train_data/rec_phl_driving_license\" \"\"\" # coding:utf8 import os import shutil import random import argparse from pathlib import Path # Delete the divided training set, validation set, and test set folder and recreate an empty folder def isCreateOrDeleteFolder ( path , flag ): flagPath = os . path . join ( path , flag ) if os . path . exists ( flagPath ): shutil . rmtree ( flagPath ) os . makedirs ( flagPath ) flagAbsPath = os . path . abspath ( flagPath ) return flagAbsPath def get_relative_path ( imageCopyPath ): \"\"\" Get relative label path from absolute Args: imageCopyPath (_type_): _description_ Returns: _type_: _description_ \"\"\" # ## Get dynamic length -- but if absolute dir path passed for saving labels, it will give more length and it will not give desired result # len_rel_folders = len(Path(args.recRootPath.strip('.').strip('/')).parents) ## We need only last 2 folders and filename of abs path len_rel_folders = 2 base_parent_folder = Path ( imageCopyPath ) . parents [ len_rel_folders ] relative_path = Path ( imageCopyPath ) . relative_to ( base_parent_folder ) return relative_path def splitTrainVal ( root , absTrainRootPath , absValRootPath , absTestRootPath , trainTxt , valTxt , testTxt , flag , args = None ): # Divide the training set, validation set, and test set according to the specified ratio dataAbsPath = os . path . abspath ( root ) if flag == \"det\" : labelFilePath = os . path . join ( dataAbsPath , args . detLabelFileName ) elif flag == \"rec\" : labelFilePath = os . path . join ( dataAbsPath , args . recLabelFileName ) labelFileRead = open ( labelFilePath , \"r\" , encoding = \"UTF-8\" ) labelFileContent = labelFileRead . readlines () random . shuffle ( labelFileContent ) labelRecordLen = len ( labelFileContent ) for index , labelRecordInfo in enumerate ( labelFileContent ): imageRelativePath = labelRecordInfo . split ( ' \\t ' )[ 0 ] imageLabel = labelRecordInfo . split ( ' \\t ' )[ 1 ] imageName = os . path . basename ( imageRelativePath ) if flag == \"det\" : imagePath = os . path . join ( dataAbsPath , imageName ) elif flag == \"rec\" : imagePath = os . path . join ( dataAbsPath , os . path . join ( args . recImageDirName , imageName )) # Divide the training set, validation set, and test set according to the preset ratio trainValTestRatio = args . trainValTestRatio . split ( \":\" ) trainRatio = eval ( trainValTestRatio [ 0 ]) / 10 valRatio = trainRatio + eval ( trainValTestRatio [ 1 ]) / 10 curRatio = index / labelRecordLen # import ipdb;ipdb.set_trace() try : if curRatio < trainRatio : imageCopyPath = os . path . join ( absTrainRootPath , imageName ) shutil . copy ( imagePath , imageCopyPath ) if args . relative_path : relative_path = get_relative_path ( imageCopyPath ) trainTxt . write ( \" {} \\t {} \" . format ( relative_path , imageLabel )) else : trainTxt . write ( \" {} \\t {} \" . format ( imageCopyPath , imageLabel )) elif curRatio >= trainRatio and curRatio < valRatio : imageCopyPath = os . path . join ( absValRootPath , imageName ) shutil . copy ( imagePath , imageCopyPath ) if args . relative_path : relative_path = get_relative_path ( imageCopyPath ) valTxt . write ( \" {} \\t {} \" . format ( relative_path , imageLabel )) else : valTxt . write ( \" {} \\t {} \" . format ( imageCopyPath , imageLabel )) else : imageCopyPath = os . path . join ( absTestRootPath , imageName ) shutil . copy ( imagePath , imageCopyPath ) if args . relative_path : relative_path = get_relative_path ( imageCopyPath ) testTxt . write ( \" {} \\t {} \" . format ( relative_path , imageLabel )) else : testTxt . write ( \" {} \\t {} \" . format ( imageCopyPath , imageLabel )) except Exception as e : print ( f \"Error: { e } \" ) # delete existing files def removeFile ( path ): if os . path . exists ( path ): os . remove ( path ) def genDetRecTrainVal ( args ): detAbsTrainRootPath = isCreateOrDeleteFolder ( args . detRootPath , \"train\" ) detAbsValRootPath = isCreateOrDeleteFolder ( args . detRootPath , \"val\" ) detAbsTestRootPath = isCreateOrDeleteFolder ( args . detRootPath , \"test\" ) recAbsTrainRootPath = isCreateOrDeleteFolder ( args . recRootPath , \"train\" ) recAbsValRootPath = isCreateOrDeleteFolder ( args . recRootPath , \"val\" ) recAbsTestRootPath = isCreateOrDeleteFolder ( args . recRootPath , \"test\" ) removeFile ( os . path . join ( args . detRootPath , \"train.txt\" )) removeFile ( os . path . join ( args . detRootPath , \"val.txt\" )) removeFile ( os . path . join ( args . detRootPath , \"test.txt\" )) removeFile ( os . path . join ( args . recRootPath , \"train.txt\" )) removeFile ( os . path . join ( args . recRootPath , \"val.txt\" )) removeFile ( os . path . join ( args . recRootPath , \"test.txt\" )) detTrainTxt = open ( os . path . join ( args . detRootPath , \"train.txt\" ), \"a\" , encoding = \"UTF-8\" ) detValTxt = open ( os . path . join ( args . detRootPath , \"val.txt\" ), \"a\" , encoding = \"UTF-8\" ) detTestTxt = open ( os . path . join ( args . detRootPath , \"test.txt\" ), \"a\" , encoding = \"UTF-8\" ) recTrainTxt = open ( os . path . join ( args . recRootPath , \"train.txt\" ), \"a\" , encoding = \"UTF-8\" ) recValTxt = open ( os . path . join ( args . recRootPath , \"val.txt\" ), \"a\" , encoding = \"UTF-8\" ) recTestTxt = open ( os . path . join ( args . recRootPath , \"test.txt\" ), \"a\" , encoding = \"UTF-8\" ) splitTrainVal ( args . datasetRootPath , detAbsTrainRootPath , detAbsValRootPath , detAbsTestRootPath , detTrainTxt , detValTxt , detTestTxt , \"det\" , args = args ) for root , dirs , files in os . walk ( args . datasetRootPath ): for dir in dirs : if dir == 'crop_img' : splitTrainVal ( root , recAbsTrainRootPath , recAbsValRootPath , recAbsTestRootPath , recTrainTxt , recValTxt , recTestTxt , \"rec\" , args = args ) else : continue break def str2bool ( v ): import argparse if isinstance ( v , bool ): return v if v . lower () in ( 'yes' , 'true' , 'True' , 't' , 'y' , '1' ): return True elif v . lower () in ( 'no' , 'false' , 'False' , 'f' , 'n' , '0' ): return False else : raise argparse . ArgumentTypeError ( 'Boolean value expected.' ) if __name__ == \"__main__\" : # Function description: separate the training set, validation set, and test set for detection and recognition # Description: You can adjust the parameters according to your own path and needs. Image data is often labeled in batches by multiple people. Each batch of image data is placed in a folder and labeled with PPOCRLabel. # In this way, there will be multiple labeled image folders to aggregate and divide the training set, validation set, and test set requirements parser = argparse . ArgumentParser () parser . add_argument ( \"--trainValTestRatio\" , type = str , default = \"7:2:1\" , help = \"ratio of trainset:valset:testset\" ) parser . add_argument ( \"--datasetRootPath\" , type = str , default = \"../train_data/\" , help = \"path to the dataset marked by ppocrlabel, E.g, dataset folder named 1,2,3...\" ) parser . add_argument ( \"--detRootPath\" , type = str , default = \"../train_data/det\" , help = \"the path where the divided detection dataset is placed\" ) parser . add_argument ( \"--recRootPath\" , type = str , default = \"../train_data/rec\" , help = \"the path where the divided recognition dataset is placed\" ) parser . add_argument ( \"--detLabelFileName\" , type = str , default = \"Label.txt\" , help = \"the name of the detection annotation file\" ) parser . add_argument ( \"--recLabelFileName\" , type = str , default = \"rec_gt.txt\" , help = \"the name of the recognition annotation file\" ) parser . add_argument ( \"--recImageDirName\" , type = str , default = \"crop_img\" , help = \"the name of the folder where the cropped recognition dataset is located\" ) parser . add_argument ( \"-r\" , \"--relative_path\" , type = str2bool , nargs = '?' , const = True , default = True , help = \"Whether to write relative paths in label file-name\" ) args = parser . parse_args () genDetRecTrainVal ( args ) After splitting annotated dataset it will create training, validation and testing folder with associated labels.","title":"Annotation tool"},{"location":"dataset_preparation/annotation-tool/#splitting-dataset","text":"Once you are ready with annotations you can export label and recognition result, that we need to split into train, validation and test set for ocr training or fine-tuning. You can use modified gen_ocr_train_val_test.py file to split dataset,that will contains relative filepath in label file, so we can use that file for training on new system easily. download code file gen_ocr_train_val_test.py \"\"\" Usage: python gen_ocr_train_val_test.py --trainValTestRatio \"8:1:1\" --datasetRootPath \"/Philippines-ids/driving-license/\" --detRootPath \"../train_data/det_phl_driving_license\" --recRootPath \"../train_data/rec_phl_driving_license\" \"\"\" # coding:utf8 import os import shutil import random import argparse from pathlib import Path # Delete the divided training set, validation set, and test set folder and recreate an empty folder def isCreateOrDeleteFolder ( path , flag ): flagPath = os . path . join ( path , flag ) if os . path . exists ( flagPath ): shutil . rmtree ( flagPath ) os . makedirs ( flagPath ) flagAbsPath = os . path . abspath ( flagPath ) return flagAbsPath def get_relative_path ( imageCopyPath ): \"\"\" Get relative label path from absolute Args: imageCopyPath (_type_): _description_ Returns: _type_: _description_ \"\"\" # ## Get dynamic length -- but if absolute dir path passed for saving labels, it will give more length and it will not give desired result # len_rel_folders = len(Path(args.recRootPath.strip('.').strip('/')).parents) ## We need only last 2 folders and filename of abs path len_rel_folders = 2 base_parent_folder = Path ( imageCopyPath ) . parents [ len_rel_folders ] relative_path = Path ( imageCopyPath ) . relative_to ( base_parent_folder ) return relative_path def splitTrainVal ( root , absTrainRootPath , absValRootPath , absTestRootPath , trainTxt , valTxt , testTxt , flag , args = None ): # Divide the training set, validation set, and test set according to the specified ratio dataAbsPath = os . path . abspath ( root ) if flag == \"det\" : labelFilePath = os . path . join ( dataAbsPath , args . detLabelFileName ) elif flag == \"rec\" : labelFilePath = os . path . join ( dataAbsPath , args . recLabelFileName ) labelFileRead = open ( labelFilePath , \"r\" , encoding = \"UTF-8\" ) labelFileContent = labelFileRead . readlines () random . shuffle ( labelFileContent ) labelRecordLen = len ( labelFileContent ) for index , labelRecordInfo in enumerate ( labelFileContent ): imageRelativePath = labelRecordInfo . split ( ' \\t ' )[ 0 ] imageLabel = labelRecordInfo . split ( ' \\t ' )[ 1 ] imageName = os . path . basename ( imageRelativePath ) if flag == \"det\" : imagePath = os . path . join ( dataAbsPath , imageName ) elif flag == \"rec\" : imagePath = os . path . join ( dataAbsPath , os . path . join ( args . recImageDirName , imageName )) # Divide the training set, validation set, and test set according to the preset ratio trainValTestRatio = args . trainValTestRatio . split ( \":\" ) trainRatio = eval ( trainValTestRatio [ 0 ]) / 10 valRatio = trainRatio + eval ( trainValTestRatio [ 1 ]) / 10 curRatio = index / labelRecordLen # import ipdb;ipdb.set_trace() try : if curRatio < trainRatio : imageCopyPath = os . path . join ( absTrainRootPath , imageName ) shutil . copy ( imagePath , imageCopyPath ) if args . relative_path : relative_path = get_relative_path ( imageCopyPath ) trainTxt . write ( \" {} \\t {} \" . format ( relative_path , imageLabel )) else : trainTxt . write ( \" {} \\t {} \" . format ( imageCopyPath , imageLabel )) elif curRatio >= trainRatio and curRatio < valRatio : imageCopyPath = os . path . join ( absValRootPath , imageName ) shutil . copy ( imagePath , imageCopyPath ) if args . relative_path : relative_path = get_relative_path ( imageCopyPath ) valTxt . write ( \" {} \\t {} \" . format ( relative_path , imageLabel )) else : valTxt . write ( \" {} \\t {} \" . format ( imageCopyPath , imageLabel )) else : imageCopyPath = os . path . join ( absTestRootPath , imageName ) shutil . copy ( imagePath , imageCopyPath ) if args . relative_path : relative_path = get_relative_path ( imageCopyPath ) testTxt . write ( \" {} \\t {} \" . format ( relative_path , imageLabel )) else : testTxt . write ( \" {} \\t {} \" . format ( imageCopyPath , imageLabel )) except Exception as e : print ( f \"Error: { e } \" ) # delete existing files def removeFile ( path ): if os . path . exists ( path ): os . remove ( path ) def genDetRecTrainVal ( args ): detAbsTrainRootPath = isCreateOrDeleteFolder ( args . detRootPath , \"train\" ) detAbsValRootPath = isCreateOrDeleteFolder ( args . detRootPath , \"val\" ) detAbsTestRootPath = isCreateOrDeleteFolder ( args . detRootPath , \"test\" ) recAbsTrainRootPath = isCreateOrDeleteFolder ( args . recRootPath , \"train\" ) recAbsValRootPath = isCreateOrDeleteFolder ( args . recRootPath , \"val\" ) recAbsTestRootPath = isCreateOrDeleteFolder ( args . recRootPath , \"test\" ) removeFile ( os . path . join ( args . detRootPath , \"train.txt\" )) removeFile ( os . path . join ( args . detRootPath , \"val.txt\" )) removeFile ( os . path . join ( args . detRootPath , \"test.txt\" )) removeFile ( os . path . join ( args . recRootPath , \"train.txt\" )) removeFile ( os . path . join ( args . recRootPath , \"val.txt\" )) removeFile ( os . path . join ( args . recRootPath , \"test.txt\" )) detTrainTxt = open ( os . path . join ( args . detRootPath , \"train.txt\" ), \"a\" , encoding = \"UTF-8\" ) detValTxt = open ( os . path . join ( args . detRootPath , \"val.txt\" ), \"a\" , encoding = \"UTF-8\" ) detTestTxt = open ( os . path . join ( args . detRootPath , \"test.txt\" ), \"a\" , encoding = \"UTF-8\" ) recTrainTxt = open ( os . path . join ( args . recRootPath , \"train.txt\" ), \"a\" , encoding = \"UTF-8\" ) recValTxt = open ( os . path . join ( args . recRootPath , \"val.txt\" ), \"a\" , encoding = \"UTF-8\" ) recTestTxt = open ( os . path . join ( args . recRootPath , \"test.txt\" ), \"a\" , encoding = \"UTF-8\" ) splitTrainVal ( args . datasetRootPath , detAbsTrainRootPath , detAbsValRootPath , detAbsTestRootPath , detTrainTxt , detValTxt , detTestTxt , \"det\" , args = args ) for root , dirs , files in os . walk ( args . datasetRootPath ): for dir in dirs : if dir == 'crop_img' : splitTrainVal ( root , recAbsTrainRootPath , recAbsValRootPath , recAbsTestRootPath , recTrainTxt , recValTxt , recTestTxt , \"rec\" , args = args ) else : continue break def str2bool ( v ): import argparse if isinstance ( v , bool ): return v if v . lower () in ( 'yes' , 'true' , 'True' , 't' , 'y' , '1' ): return True elif v . lower () in ( 'no' , 'false' , 'False' , 'f' , 'n' , '0' ): return False else : raise argparse . ArgumentTypeError ( 'Boolean value expected.' ) if __name__ == \"__main__\" : # Function description: separate the training set, validation set, and test set for detection and recognition # Description: You can adjust the parameters according to your own path and needs. Image data is often labeled in batches by multiple people. Each batch of image data is placed in a folder and labeled with PPOCRLabel. # In this way, there will be multiple labeled image folders to aggregate and divide the training set, validation set, and test set requirements parser = argparse . ArgumentParser () parser . add_argument ( \"--trainValTestRatio\" , type = str , default = \"7:2:1\" , help = \"ratio of trainset:valset:testset\" ) parser . add_argument ( \"--datasetRootPath\" , type = str , default = \"../train_data/\" , help = \"path to the dataset marked by ppocrlabel, E.g, dataset folder named 1,2,3...\" ) parser . add_argument ( \"--detRootPath\" , type = str , default = \"../train_data/det\" , help = \"the path where the divided detection dataset is placed\" ) parser . add_argument ( \"--recRootPath\" , type = str , default = \"../train_data/rec\" , help = \"the path where the divided recognition dataset is placed\" ) parser . add_argument ( \"--detLabelFileName\" , type = str , default = \"Label.txt\" , help = \"the name of the detection annotation file\" ) parser . add_argument ( \"--recLabelFileName\" , type = str , default = \"rec_gt.txt\" , help = \"the name of the recognition annotation file\" ) parser . add_argument ( \"--recImageDirName\" , type = str , default = \"crop_img\" , help = \"the name of the folder where the cropped recognition dataset is located\" ) parser . add_argument ( \"-r\" , \"--relative_path\" , type = str2bool , nargs = '?' , const = True , default = True , help = \"Whether to write relative paths in label file-name\" ) args = parser . parse_args () genDetRecTrainVal ( args ) After splitting annotated dataset it will create training, validation and testing folder with associated labels.","title":"Splitting dataset:"},{"location":"dataset_preparation/paddleocr_dataset_format/","text":"Paddleocr format \u00b6 1. Text detection \u00b6 1.1 PaddleOCR text detection format annotation \u00b6 The annotation file formats supported by the PaddleOCR text detection algorithm are as follows, separated by \"\\t\": \" Image file name Image annotation information encoded by json.dumps\" ch4_test_images/img_61.jpg [{\"transcription\": \"MASA\", \"points\": [[310, 104], [416, 141], [418, 216], [312, 179]]}, {...}] The image annotation after json.dumps() encoding is a list containing multiple dictionaries. The points in the dictionary represent the coordinates (x, y) of the four points of the text box, arranged clockwise from the point at the upper left corner. transcription represents the text of the current text box. When its content is \"###\" it means that the text box is invalid and will be skipped during training. If you want to train PaddleOCR on other datasets, please build the annotation file according to the above format. 1.2 Public dataset \u00b6 dataset Image download link PaddleOCR format annotation download link ICDAR 2015 https://rrc.cvc.uab.es/?ch=4&com=downloads train / test ctw1500 https://paddleocr.bj.bcebos.com/dataset/ctw1500.zip Included in the downloaded image zip total text https://paddleocr.bj.bcebos.com/dataset/total_text.tar Included in the downloaded image zip 1.2.1 ICDAR 2015 \u00b6 The icdar2015 dataset contains train set which has 1000 images obtained with wearable cameras and test set which has 500 images obtained with wearable cameras. The icdar2015 dataset can be downloaded from the link in the table above. Registration is required for downloading. After registering and logging in, download the part marked in the red box in the figure below. And, the content downloaded by Training Set Images should be saved as the folder icdar_c4_train_imgs , and the content downloaded by Test Set Images is saved as the folder ch4_test_images Decompress the downloaded dataset to the working directory, assuming it is decompressed under PaddleOCR/train_data/. Then download the PaddleOCR format annotation file from the table above. PaddleOCR also provides a data format conversion script, which can convert the official website label to the PaddleOCR format. The data conversion tool is in ppocr/utils/gen_label.py , here is the training set as an example: # Convert the label file downloaded from the official website to train_icdar2015_label.txt python gen_label.py --mode=\"det\" --root_path=\"/path/to/icdar_c4_train_imgs/\" \\ --input_path=\"/path/to/ch4_training_localization_transcription_gt\" \\ --output_label=\"/path/to/train_icdar2015_label.txt\" After decompressing the data set and downloading the annotation file, PaddleOCR/train_data/ has two folders and two files, which are: /PaddleOCR/train_data/icdar2015/text_localization/ \u2514\u2500 icdar_c4_train_imgs/ Training data of icdar dataset \u2514\u2500 ch4_test_images/ Testing data of icdar dataset \u2514\u2500 train_icdar2015_label.txt Training annotation of icdar dataset \u2514\u2500 test_icdar2015_label.txt Test annotation of icdar dataset 2. Text recognition \u00b6 2.1 PaddleOCR text recognition format annotation \u00b6 The text recognition algorithm in PaddleOCR supports two data formats: - lmdb is used to train data sets stored in lmdb format, use lmdb_dataset.py to load; - common dataset is used to train data sets stored in text files, use simple_dataset.py to load. If you want to use your own data for training, please refer to the following to organize your data. Training set It is recommended to put the training images in the same folder, and use a txt file (rec_gt_train.txt) to store the image path and label. The contents of the txt file are as follows: Note: by default, the image path and image label are split with \\t, if you use other methods to split, it will cause training error \" Image file name Image annotation \" train_data/rec/train/word_001.jpg \u7b80\u5355\u53ef\u4f9d\u8d56 train_data/rec/train/word_002.jpg \u7528\u79d1\u6280\u8ba9\u590d\u6742\u7684\u4e16\u754c\u66f4\u7b80\u5355 ... The final training set should have the following file structure: |-train_data |-rec |- rec_gt_train.txt |- train |- word_001.png |- word_002.jpg |- word_003.jpg | ... Test set Similar to the training set, the test set also needs to be provided a folder containing all images (test) and a rec_gt_test.txt. The structure of the test set is as follows: |-train_data |-rec |-ic15_data |- rec_gt_test.txt |- test |- word_001.jpg |- word_002.jpg |- word_003.jpg | ... 2.2 Public dataset \u00b6 dataset Image download link PaddleOCR format annotation download link en benchmark(MJ, SJ, IIIT, SVT, IC03, IC13, IC15, SVTP, and CUTE.) DTRB LMDB format, which can be loaded directly with lmdb_dataset.py ICDAR 2015 http://rrc.cvc.uab.es/?ch=4&com=downloads train / test Multilingual datasets Baidu network disk Extraction code: frgi google drive Included in the downloaded image zip 2.1 ICDAR 2015 \u00b6 The ICDAR 2015 dataset can be downloaded from the link in the table above for quick validation. The lmdb format dataset required by en benchmark can also be downloaded from the table above. Then download the PaddleOCR format annotation file from the table above. PaddleOCR also provides a data format conversion script, which can convert the ICDAR official website label to the data format supported by PaddleOCR. The data conversion tool is in ppocr/utils/gen_label.py , here is the training set as an example: # Convert the label file downloaded from the official website to rec_gt_label.txt python gen_label.py --mode=\"rec\" --input_path=\"{path/of/origin/label}\" --output_label=\"rec_gt_label.txt\" The data format is as follows, (a) is the original picture, (b) is the Ground Truth text file corresponding to each picture: 3. Data storage path \u00b6 The default storage path for PaddleOCR training data is PaddleOCR/train_data , if you already have a dataset on your disk, just create a soft link to the dataset directory: # linux and mac os ln -sf <path/to/dataset> <path/to/paddle_ocr>/train_data/dataset # windows mklink /d <path/to/paddle_ocr>/train_data/dataset <path/to/dataset>","title":"Paddleocr format"},{"location":"dataset_preparation/paddleocr_dataset_format/#paddleocr-format","text":"","title":"Paddleocr format"},{"location":"dataset_preparation/paddleocr_dataset_format/#1-text-detection","text":"","title":"1. Text detection"},{"location":"dataset_preparation/paddleocr_dataset_format/#11-paddleocr-text-detection-format-annotation","text":"The annotation file formats supported by the PaddleOCR text detection algorithm are as follows, separated by \"\\t\": \" Image file name Image annotation information encoded by json.dumps\" ch4_test_images/img_61.jpg [{\"transcription\": \"MASA\", \"points\": [[310, 104], [416, 141], [418, 216], [312, 179]]}, {...}] The image annotation after json.dumps() encoding is a list containing multiple dictionaries. The points in the dictionary represent the coordinates (x, y) of the four points of the text box, arranged clockwise from the point at the upper left corner. transcription represents the text of the current text box. When its content is \"###\" it means that the text box is invalid and will be skipped during training. If you want to train PaddleOCR on other datasets, please build the annotation file according to the above format.","title":"1.1 PaddleOCR text detection format annotation"},{"location":"dataset_preparation/paddleocr_dataset_format/#12-public-dataset","text":"dataset Image download link PaddleOCR format annotation download link ICDAR 2015 https://rrc.cvc.uab.es/?ch=4&com=downloads train / test ctw1500 https://paddleocr.bj.bcebos.com/dataset/ctw1500.zip Included in the downloaded image zip total text https://paddleocr.bj.bcebos.com/dataset/total_text.tar Included in the downloaded image zip","title":"1.2 Public dataset"},{"location":"dataset_preparation/paddleocr_dataset_format/#121-icdar-2015","text":"The icdar2015 dataset contains train set which has 1000 images obtained with wearable cameras and test set which has 500 images obtained with wearable cameras. The icdar2015 dataset can be downloaded from the link in the table above. Registration is required for downloading. After registering and logging in, download the part marked in the red box in the figure below. And, the content downloaded by Training Set Images should be saved as the folder icdar_c4_train_imgs , and the content downloaded by Test Set Images is saved as the folder ch4_test_images Decompress the downloaded dataset to the working directory, assuming it is decompressed under PaddleOCR/train_data/. Then download the PaddleOCR format annotation file from the table above. PaddleOCR also provides a data format conversion script, which can convert the official website label to the PaddleOCR format. The data conversion tool is in ppocr/utils/gen_label.py , here is the training set as an example: # Convert the label file downloaded from the official website to train_icdar2015_label.txt python gen_label.py --mode=\"det\" --root_path=\"/path/to/icdar_c4_train_imgs/\" \\ --input_path=\"/path/to/ch4_training_localization_transcription_gt\" \\ --output_label=\"/path/to/train_icdar2015_label.txt\" After decompressing the data set and downloading the annotation file, PaddleOCR/train_data/ has two folders and two files, which are: /PaddleOCR/train_data/icdar2015/text_localization/ \u2514\u2500 icdar_c4_train_imgs/ Training data of icdar dataset \u2514\u2500 ch4_test_images/ Testing data of icdar dataset \u2514\u2500 train_icdar2015_label.txt Training annotation of icdar dataset \u2514\u2500 test_icdar2015_label.txt Test annotation of icdar dataset","title":"1.2.1 ICDAR 2015"},{"location":"dataset_preparation/paddleocr_dataset_format/#2-text-recognition","text":"","title":"2. Text recognition"},{"location":"dataset_preparation/paddleocr_dataset_format/#21-paddleocr-text-recognition-format-annotation","text":"The text recognition algorithm in PaddleOCR supports two data formats: - lmdb is used to train data sets stored in lmdb format, use lmdb_dataset.py to load; - common dataset is used to train data sets stored in text files, use simple_dataset.py to load. If you want to use your own data for training, please refer to the following to organize your data. Training set It is recommended to put the training images in the same folder, and use a txt file (rec_gt_train.txt) to store the image path and label. The contents of the txt file are as follows: Note: by default, the image path and image label are split with \\t, if you use other methods to split, it will cause training error \" Image file name Image annotation \" train_data/rec/train/word_001.jpg \u7b80\u5355\u53ef\u4f9d\u8d56 train_data/rec/train/word_002.jpg \u7528\u79d1\u6280\u8ba9\u590d\u6742\u7684\u4e16\u754c\u66f4\u7b80\u5355 ... The final training set should have the following file structure: |-train_data |-rec |- rec_gt_train.txt |- train |- word_001.png |- word_002.jpg |- word_003.jpg | ... Test set Similar to the training set, the test set also needs to be provided a folder containing all images (test) and a rec_gt_test.txt. The structure of the test set is as follows: |-train_data |-rec |-ic15_data |- rec_gt_test.txt |- test |- word_001.jpg |- word_002.jpg |- word_003.jpg | ...","title":"2.1 PaddleOCR text recognition format annotation"},{"location":"dataset_preparation/paddleocr_dataset_format/#22-public-dataset","text":"dataset Image download link PaddleOCR format annotation download link en benchmark(MJ, SJ, IIIT, SVT, IC03, IC13, IC15, SVTP, and CUTE.) DTRB LMDB format, which can be loaded directly with lmdb_dataset.py ICDAR 2015 http://rrc.cvc.uab.es/?ch=4&com=downloads train / test Multilingual datasets Baidu network disk Extraction code: frgi google drive Included in the downloaded image zip","title":"2.2 Public dataset"},{"location":"dataset_preparation/paddleocr_dataset_format/#21-icdar-2015","text":"The ICDAR 2015 dataset can be downloaded from the link in the table above for quick validation. The lmdb format dataset required by en benchmark can also be downloaded from the table above. Then download the PaddleOCR format annotation file from the table above. PaddleOCR also provides a data format conversion script, which can convert the ICDAR official website label to the data format supported by PaddleOCR. The data conversion tool is in ppocr/utils/gen_label.py , here is the training set as an example: # Convert the label file downloaded from the official website to rec_gt_label.txt python gen_label.py --mode=\"rec\" --input_path=\"{path/of/origin/label}\" --output_label=\"rec_gt_label.txt\" The data format is as follows, (a) is the original picture, (b) is the Ground Truth text file corresponding to each picture:","title":"2.1 ICDAR 2015"},{"location":"dataset_preparation/paddleocr_dataset_format/#3-data-storage-path","text":"The default storage path for PaddleOCR training data is PaddleOCR/train_data , if you already have a dataset on your disk, just create a soft link to the dataset directory: # linux and mac os ln -sf <path/to/dataset> <path/to/paddle_ocr>/train_data/dataset # windows mklink /d <path/to/paddle_ocr>/train_data/dataset <path/to/dataset>","title":"3. Data storage path"},{"location":"training/recognition_paddleocr/","text":"Recognition Paddleocr \u00b6 Colab demo notebook link You can clone demo notebook and check training process. For more details you can refer below doc. Text Recognition training \u00b6 1. Data Preparation 1.1 Custom Dataset 1.2 Dataset Download 1.3 Dictionary 1.4 Add Space Category 1.5 Data Augmentation 2. Training 2.1 Start Training 2.2 Load Trained Model and Continue Training 2.3 Training with New Backbone 2.4 Mixed Precision Training 2.5 Distributed Training 2.6 Training with knowledge distillation 2.7 Multi-language Training 2.8 Training on other platform(Windows/macOS/Linux DCU) 3. Evaluation and Test 3.1 Evaluation 3.2 Test 4. Inference 5. FAQ 1. Data Preparation \u00b6 1.1 DataSet Preparation \u00b6 To prepare datasets, refer to ocr_datasets . PaddleOCR provides label files for training the icdar2015 dataset, which can be downloaded in the following ways: # Training set label wget -P ./train_data/ic15_data https://paddleocr.bj.bcebos.com/dataset/rec_gt_train.txt # Test Set Label wget -P ./train_data/ic15_data https://paddleocr.bj.bcebos.com/dataset/rec_gt_test.txt PaddleOCR also provides a data format conversion script, which can convert ICDAR official website label to a data format supported by PaddleOCR. The data conversion tool is in ppocr/utils/gen_label.py , here is the training set as an example: # convert the official gt to rec_gt_label.txt python gen_label.py --mode=\"rec\" --input_path=\"{path/of/origin/label}\" --output_label=\"rec_gt_label.txt\" The data format is as follows, (a) is the original picture, (b) is the Ground Truth text file corresponding to each picture: Multilingual dataset The multi-language model training method is the same as the Chinese model. The training data set is 100w synthetic data. A small amount of fonts and test data can be downloaded using the following two methods. * Baidu Netdisk ,Extraction code:frgi. * Google drive 1.2 Dictionary \u00b6 Finally, a dictionary ({word_dict_name}.txt) needs to be provided so that when the model is trained, all the characters that appear can be mapped to the dictionary index. Therefore, the dictionary needs to contain all the characters that you want to be recognized correctly. {word_dict_name}.txt needs to be written in the following format and saved in the utf-8 encoding format: l d a d r n In word_dict.txt , there is a single word in each line, which maps characters and numeric indexes together, e.g \"and\" will be mapped to [2 5 1] PaddleOCR has built-in dictionaries, which can be used on demand. ppocr/utils/ppocr_keys_v1.txt is a Chinese dictionary with 6623 characters. ppocr/utils/ic15_dict.txt is an English dictionary with 63 characters ppocr/utils/dict/french_dict.txt is a French dictionary with 118 characters ppocr/utils/dict/japan_dict.txt is a Japanese dictionary with 4399 characters ppocr/utils/dict/korean_dict.txt is a Korean dictionary with 3636 characters ppocr/utils/dict/german_dict.txt is a German dictionary with 131 characters ppocr/utils/en_dict.txt is a English dictionary with 96 characters The current multi-language model is still in the demo stage and will continue to optimize the model and add languages. You are very welcome to provide us with dictionaries and fonts in other languages , If you like, you can submit the dictionary file to dict and we will thank you in the Repo. To customize the dict file, please modify the character_dict_path field in configs/rec/rec_icdar15_train.yml . Custom dictionary If you need to customize dic file, please add character_dict_path field in configs/rec/rec_icdar15_train.yml to point to your dictionary path. And set character_type to ch. 1.4 Add Space Category \u00b6 If you want to support the recognition of the space category, please set the use_space_char field in the yml file to True . 1.5 Data Augmentation \u00b6 PaddleOCR provides a variety of data augmentation methods. All the augmentation methods are enabled by default. The default perturbation methods are: cvtColor, blur, jitter, Gasuss noise, random crop, perspective, color reverse, TIA augmentation. Each disturbance method is selected with a 40% probability during the training process. For specific code implementation, please refer to: rec_img_aug.py 2.Training \u00b6 PaddleOCR provides training scripts, evaluation scripts, and prediction scripts. In this section, the CRNN recognition model will be used as an example: 2.1 Start Training \u00b6 First download the pretrain model, you can download the trained model to finetune on the icdar2015 data: cd PaddleOCR/ # Download the pre-trained model of en_PP-OCRv3 wget -P ./pretrain_models/ https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_rec_train.tar # Decompress model parameters cd pretrain_models tar -xf en_PP-OCRv3_rec_train.tar && rm -rf en_PP-OCRv3_rec_train.tar Start training: # GPU training Support single card and multi-card training # Training icdar15 English data and The training log will be automatically saved as train.log under \"{save_model_dir}\" #specify the single card training(Long training time, not recommended) python3 tools/train.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=en_PP-OCRv3_rec_train/best_accuracy #specify the card number through --gpus python3 -m paddle.distributed.launch --gpus '0,1,2,3' tools/train.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=en_PP-OCRv3_rec_train/best_accuracy PaddleOCR supports alternating training and evaluation. You can modify eval_batch_step in configs/rec/rec_icdar15_train.yml to set the evaluation frequency. By default, it is evaluated every 500 iter and the best acc model is saved under output/rec_CRNN/best_accuracy during the evaluation process. If the evaluation set is large, the test will be time-consuming. It is recommended to reduce the number of evaluations, or evaluate after training. Tip: You can use the -c parameter to select multiple model configurations under the configs/rec/ path for training. The recognition algorithms supported at rec_algorithm : For training Chinese data, it is recommended to use ch_PP-OCRv3_rec_distillation.yml . If you want to try the result of other algorithms on the Chinese data set, please refer to the following instructions to modify the configuration file: Take ch_PP-OCRv3_rec_distillation.yml as an example: Global: ... # Add a custom dictionary, such as modify the dictionary, please point the path to the new dictionary character_dict_path: ppocr/utils/ppocr_keys_v1.txt # Modify character type ... # Whether to recognize spaces use_space_char: True Optimizer: ... # Add learning rate decay strategy lr: name: Cosine learning_rate: 0.001 ... ... Train: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data/ # Path of train list label_file_list: [\"./train_data/train_list.txt\"] transforms: ... - RecResizeImg: # Modify image_shape to fit long text image_shape: [3, 48, 320] ... loader: ... # Train batch_size for Single card batch_size_per_card: 256 ... Eval: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data # Path of eval list label_file_list: [\"./train_data/val_list.txt\"] transforms: ... - RecResizeImg: # Modify image_shape to fit long text image_shape: [3, 48, 320] ... loader: # Eval batch_size for Single card batch_size_per_card: 256 ... Note that the configuration file for prediction/evaluation must be consistent with the training. 2.2 Load Trained Model and Continue Training \u00b6 If you expect to load trained model and continue the training again, you can specify the parameter Global.checkpoints as the model path to be loaded. For example: python3 tools/train.py -c configs/rec/rec_icdar15_train.yml -o Global.checkpoints = ./your/trained/model Note : The priority of Global.checkpoints is higher than that of Global.pretrained_model , that is, when two parameters are specified at the same time, the model specified by Global.checkpoints will be loaded first. If the model path specified by Global.checkpoints is wrong, the one specified by Global.pretrained_model will be loaded. 2.3 Training with New Backbone \u00b6 The network part completes the construction of the network, and PaddleOCR divides the network into four parts, which are under ppocr/modeling . The data entering the network will pass through these four parts in sequence(transforms->backbones-> necks->heads). \u251c\u2500\u2500 architectures # Code for building network \u251c\u2500\u2500 transforms # Image Transformation Module \u251c\u2500\u2500 backbones # Feature extraction module \u251c\u2500\u2500 necks # Feature enhancement module \u2514\u2500\u2500 heads # Output module If the Backbone to be replaced has a corresponding implementation in PaddleOCR, you can directly modify the parameters in the Backbone part of the configuration yml file. However, if you want to use a new Backbone, an example of replacing the backbones is as follows: Create a new file under the ppocr/modeling/backbones folder, such as my_backbone.py. Add code in the my_backbone.py file, the sample code is as follows: import paddle import paddle.nn as nn import paddle.nn.functional as F class MyBackbone ( nn . Layer ): def __init__ ( self , * args , ** kwargs ): super ( MyBackbone , self ) . __init__ () # your init code self . conv = nn . xxxx def forward ( self , inputs ): # your network forward y = self . conv ( inputs ) return y Import the added module in the ppocr/modeling/backbones/_ init_ .py file. After adding the four-part modules of the network, you only need to configure them in the configuration file to use, such as: Backbone : name : MyBackbone args1 : args1 NOTE : More details about replace Backbone and other mudule can be found in doc . 2.4 Mixed Precision Training \u00b6 If you want to speed up your training further, you can use Auto Mixed Precision Training , taking a single machine and a single gpu as an example, the commands are as follows: python3 tools/train.py -c configs/rec/rec_icdar15_train.yml \\ -o Global.pretrained_model = ./pretrain_models/rec_mv3_none_bilstm_ctc_v2.0_train \\ Global.use_amp = True Global.scale_loss = 1024 .0 Global.use_dynamic_loss_scaling = True ``` <a name = \"25-distributed-training\" ></a> ### 2.5 Distributed Training During multi-machine multi-gpu training, use the ` --ips ` parameter to set the used machine IP address, and the ` --gpus ` parameter to set the used GPU ID: ``` bash python3 -m paddle.distributed.launch --ips = \"xx.xx.xx.xx,xx.xx.xx.xx\" --gpus '0,1,2,3' tools/train.py -c configs/rec/rec_icdar15_train.yml \\ -o Global.pretrained_model = ./pretrain_models/rec_mv3_none_bilstm_ctc_v2.0_train Note: (1) When using multi-machine and multi-gpu training, you need to replace the ips value in the above command with the address of your machine, and the machines need to be able to ping each other. (2) Training needs to be launched separately on multiple machines. The command to view the ip address of the machine is ifconfig . (3) For more details about the distributed training speedup ratio, please refer to Distributed Training Tutorial . 2.6 Training with Knowledge Distillation \u00b6 Knowledge distillation is supported in PaddleOCR for text recognition training process. For more details, please refer to doc . 2.7 Multi-language Training \u00b6 Currently, the multi-language algorithms supported by PaddleOCR are: Configuration file Algorithm name backbone trans seq pred language rec_chinese_cht_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc chinese traditional rec_en_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc English(Case sensitive) rec_french_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc French rec_ger_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc German rec_japan_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc Japanese rec_korean_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc Korean rec_latin_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc Latin rec_arabic_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc arabic rec_cyrillic_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc cyrillic rec_devanagari_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc devanagari For more supported languages, please refer to : Multi-language model If you want to finetune on the basis of the existing model effect, please refer to the following instructions to modify the configuration file: Take rec_french_lite_train as an example: Global: ... # Add a custom dictionary, such as modify the dictionary, please point the path to the new dictionary character_dict_path: ./ppocr/utils/dict/french_dict.txt ... # Whether to recognize spaces use_space_char: True ... Train: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data/ # Path of train list label_file_list: [\"./train_data/french_train.txt\"] ... Eval: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data # Path of eval list label_file_list: [\"./train_data/french_val.txt\"] ... 2.8 Training on other platform(Windows/macOS/Linux DCU) \u00b6 Windows GPU/CPU The Windows platform is slightly different from the Linux platform: Windows platform only supports single gpu training and inference, specify GPU for training set CUDA_VISIBLE_DEVICES=0 On the Windows platform, DataLoader only supports single-process mode, so you need to set num_workers to 0; macOS GPU mode is not supported, you need to set use_gpu to False in the configuration file, and the rest of the training evaluation prediction commands are exactly the same as Linux GPU. Linux DCU Running on a DCU device requires setting the environment variable export HIP_VISIBLE_DEVICES=0,1,2,3 , and the rest of the training and evaluation prediction commands are exactly the same as the Linux GPU. 3. Evaluation and Test \u00b6 3.1 Evaluation \u00b6 The model parameters during training are saved in the Global.save_model_dir directory by default. When evaluating indicators, you need to set Global.checkpoints to point to the saved parameter file. The evaluation dataset can be set by modifying the Eval.dataset.label_file_list field in the configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml file. # GPU evaluation, Global.checkpoints is the weight to be tested python3 -m paddle.distributed.launch --gpus '0' tools/eval.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.checkpoints={path/to/weights}/best_accuracy 3.2 Test \u00b6 Using the model trained by paddleocr, you can quickly get prediction through the following script. The default prediction picture is stored in infer_img , and the trained weight is specified via -o Global.checkpoints : According to the save_model_dir and save_epoch_step fields set in the configuration file, the following parameters will be saved: output/rec/ \u251c\u2500\u2500 best_accuracy.pdopt \u251c\u2500\u2500 best_accuracy.pdparams \u251c\u2500\u2500 best_accuracy.states \u251c\u2500\u2500 config.yml \u251c\u2500\u2500 iter_epoch_3.pdopt \u251c\u2500\u2500 iter_epoch_3.pdparams \u251c\u2500\u2500 iter_epoch_3.states \u251c\u2500\u2500 latest.pdopt \u251c\u2500\u2500 latest.pdparams \u251c\u2500\u2500 latest.states \u2514\u2500\u2500 train.log Among them, best_accuracy. is the best model on the evaluation set; iter_epoch_x. is the model saved at intervals of save_epoch_step ; latest.* is the model of the last epoch. # Predict English results python3 tools/infer_rec.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model={path/to/weights}/best_accuracy Global.infer_img=doc/imgs_words/en/word_1.png Input image: Get the prediction result of the input image: infer_img: doc/imgs_words/en/word_1.png result: ('joint', 0.9998967) The configuration file used for prediction must be consistent with the training. For example, you completed the training of the Chinese model with python3 tools/train.py -c configs/rec/ch_ppocr_v2.0/rec_chinese_lite_train_v2.0.yml , you can use the following command to predict the Chinese model: # Predict Chinese results python3 tools/infer_rec.py -c configs/rec/ch_ppocr_v2.0/rec_chinese_lite_train_v2.0.yml -o Global.pretrained_model={path/to/weights}/best_accuracy Global.infer_img=doc/imgs_words/ch/word_1.jpg Input image: Get the prediction result of the input image: infer_img: doc/imgs_words/ch/word_1.jpg result: ('\u97e9\u56fd\u5c0f\u9986', 0.997218) 4. Inference \u00b6 The inference model (the model saved by paddle.jit.save ) is generally a solidified model saved after the model training is completed, and is mostly used to give prediction in deployment. The model saved during the training process is the checkpoints model, which saves the parameters of the model and is mostly used to resume training. Compared with the checkpoints model, the inference model will additionally save the structural information of the model. Therefore, it is easier to deploy because the model structure and model parameters are already solidified in the inference model file, and is suitable for integration with actual systems. The recognition model is converted to the inference model in the same way as the detection, as follows: # -c Set the training algorithm yml configuration file # -o Set optional parameters # Global.pretrained_model parameter Set the training model address to be converted without adding the file suffix .pdmodel, .pdopt or .pdparams. # Global.save_inference_dir Set the address where the converted model will be saved. python3 tools/export_model.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=en_PP-OCRv3_rec_train/best_accuracy Global.save_inference_dir=./inference/en_PP-OCRv3_rec/ If you have a model trained on your own dataset with a different dictionary file, please make sure that you modify the character_dict_path in the configuration file to your dictionary file path. After the conversion is successful, there are three files in the model save directory: inference/en_PP-OCRv3_rec/ \u251c\u2500\u2500 inference.pdiparams # The parameter file of recognition inference model \u251c\u2500\u2500 inference.pdiparams.info # The parameter information of recognition inference model, which can be ignored \u2514\u2500\u2500 inference.pdmodel # The program file of recognition model Text recognition model Inference using custom characters dictionary If the text dictionary is modified during training, when using the inference model to predict, you need to specify the dictionary path used by --rec_char_dict_path python3 tools/infer/predict_rec.py --image_dir=\"./doc/imgs_words_en/word_336.png\" --rec_model_dir=\"./your inference model\" --rec_image_shape=\"3, 32, 100\" --rec_char_dict_path=\"your text dict path\" 5. FAQ \u00b6 Q1: After the training model is transferred to the inference model, the prediction effect is inconsistent? A : There are many such problems, and the problems are mostly caused by inconsistent preprocessing and postprocessing parameters when the trained model predicts and the preprocessing and postprocessing parameters when the inference model predicts. You can compare whether there are differences in preprocessing, postprocessing, and prediction in the configuration files used for training. 6. Reference: \u00b6 recognition_en.md training_en.md","title":"Recognition Paddleocr"},{"location":"training/recognition_paddleocr/#recognition-paddleocr","text":"Colab demo notebook link You can clone demo notebook and check training process. For more details you can refer below doc.","title":"Recognition Paddleocr"},{"location":"training/recognition_paddleocr/#text-recognition-training","text":"1. Data Preparation 1.1 Custom Dataset 1.2 Dataset Download 1.3 Dictionary 1.4 Add Space Category 1.5 Data Augmentation 2. Training 2.1 Start Training 2.2 Load Trained Model and Continue Training 2.3 Training with New Backbone 2.4 Mixed Precision Training 2.5 Distributed Training 2.6 Training with knowledge distillation 2.7 Multi-language Training 2.8 Training on other platform(Windows/macOS/Linux DCU) 3. Evaluation and Test 3.1 Evaluation 3.2 Test 4. Inference 5. FAQ","title":"Text Recognition training"},{"location":"training/recognition_paddleocr/#1-data-preparation","text":"","title":"1. Data Preparation"},{"location":"training/recognition_paddleocr/#11-dataset-preparation","text":"To prepare datasets, refer to ocr_datasets . PaddleOCR provides label files for training the icdar2015 dataset, which can be downloaded in the following ways: # Training set label wget -P ./train_data/ic15_data https://paddleocr.bj.bcebos.com/dataset/rec_gt_train.txt # Test Set Label wget -P ./train_data/ic15_data https://paddleocr.bj.bcebos.com/dataset/rec_gt_test.txt PaddleOCR also provides a data format conversion script, which can convert ICDAR official website label to a data format supported by PaddleOCR. The data conversion tool is in ppocr/utils/gen_label.py , here is the training set as an example: # convert the official gt to rec_gt_label.txt python gen_label.py --mode=\"rec\" --input_path=\"{path/of/origin/label}\" --output_label=\"rec_gt_label.txt\" The data format is as follows, (a) is the original picture, (b) is the Ground Truth text file corresponding to each picture: Multilingual dataset The multi-language model training method is the same as the Chinese model. The training data set is 100w synthetic data. A small amount of fonts and test data can be downloaded using the following two methods. * Baidu Netdisk ,Extraction code:frgi. * Google drive","title":"1.1 DataSet Preparation"},{"location":"training/recognition_paddleocr/#12-dictionary","text":"Finally, a dictionary ({word_dict_name}.txt) needs to be provided so that when the model is trained, all the characters that appear can be mapped to the dictionary index. Therefore, the dictionary needs to contain all the characters that you want to be recognized correctly. {word_dict_name}.txt needs to be written in the following format and saved in the utf-8 encoding format: l d a d r n In word_dict.txt , there is a single word in each line, which maps characters and numeric indexes together, e.g \"and\" will be mapped to [2 5 1] PaddleOCR has built-in dictionaries, which can be used on demand. ppocr/utils/ppocr_keys_v1.txt is a Chinese dictionary with 6623 characters. ppocr/utils/ic15_dict.txt is an English dictionary with 63 characters ppocr/utils/dict/french_dict.txt is a French dictionary with 118 characters ppocr/utils/dict/japan_dict.txt is a Japanese dictionary with 4399 characters ppocr/utils/dict/korean_dict.txt is a Korean dictionary with 3636 characters ppocr/utils/dict/german_dict.txt is a German dictionary with 131 characters ppocr/utils/en_dict.txt is a English dictionary with 96 characters The current multi-language model is still in the demo stage and will continue to optimize the model and add languages. You are very welcome to provide us with dictionaries and fonts in other languages , If you like, you can submit the dictionary file to dict and we will thank you in the Repo. To customize the dict file, please modify the character_dict_path field in configs/rec/rec_icdar15_train.yml . Custom dictionary If you need to customize dic file, please add character_dict_path field in configs/rec/rec_icdar15_train.yml to point to your dictionary path. And set character_type to ch.","title":"1.2 Dictionary"},{"location":"training/recognition_paddleocr/#14-add-space-category","text":"If you want to support the recognition of the space category, please set the use_space_char field in the yml file to True .","title":"1.4 Add Space Category"},{"location":"training/recognition_paddleocr/#15-data-augmentation","text":"PaddleOCR provides a variety of data augmentation methods. All the augmentation methods are enabled by default. The default perturbation methods are: cvtColor, blur, jitter, Gasuss noise, random crop, perspective, color reverse, TIA augmentation. Each disturbance method is selected with a 40% probability during the training process. For specific code implementation, please refer to: rec_img_aug.py","title":"1.5 Data Augmentation"},{"location":"training/recognition_paddleocr/#2training","text":"PaddleOCR provides training scripts, evaluation scripts, and prediction scripts. In this section, the CRNN recognition model will be used as an example:","title":"2.Training"},{"location":"training/recognition_paddleocr/#21-start-training","text":"First download the pretrain model, you can download the trained model to finetune on the icdar2015 data: cd PaddleOCR/ # Download the pre-trained model of en_PP-OCRv3 wget -P ./pretrain_models/ https://paddleocr.bj.bcebos.com/PP-OCRv3/english/en_PP-OCRv3_rec_train.tar # Decompress model parameters cd pretrain_models tar -xf en_PP-OCRv3_rec_train.tar && rm -rf en_PP-OCRv3_rec_train.tar Start training: # GPU training Support single card and multi-card training # Training icdar15 English data and The training log will be automatically saved as train.log under \"{save_model_dir}\" #specify the single card training(Long training time, not recommended) python3 tools/train.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=en_PP-OCRv3_rec_train/best_accuracy #specify the card number through --gpus python3 -m paddle.distributed.launch --gpus '0,1,2,3' tools/train.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=en_PP-OCRv3_rec_train/best_accuracy PaddleOCR supports alternating training and evaluation. You can modify eval_batch_step in configs/rec/rec_icdar15_train.yml to set the evaluation frequency. By default, it is evaluated every 500 iter and the best acc model is saved under output/rec_CRNN/best_accuracy during the evaluation process. If the evaluation set is large, the test will be time-consuming. It is recommended to reduce the number of evaluations, or evaluate after training. Tip: You can use the -c parameter to select multiple model configurations under the configs/rec/ path for training. The recognition algorithms supported at rec_algorithm : For training Chinese data, it is recommended to use ch_PP-OCRv3_rec_distillation.yml . If you want to try the result of other algorithms on the Chinese data set, please refer to the following instructions to modify the configuration file: Take ch_PP-OCRv3_rec_distillation.yml as an example: Global: ... # Add a custom dictionary, such as modify the dictionary, please point the path to the new dictionary character_dict_path: ppocr/utils/ppocr_keys_v1.txt # Modify character type ... # Whether to recognize spaces use_space_char: True Optimizer: ... # Add learning rate decay strategy lr: name: Cosine learning_rate: 0.001 ... ... Train: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data/ # Path of train list label_file_list: [\"./train_data/train_list.txt\"] transforms: ... - RecResizeImg: # Modify image_shape to fit long text image_shape: [3, 48, 320] ... loader: ... # Train batch_size for Single card batch_size_per_card: 256 ... Eval: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data # Path of eval list label_file_list: [\"./train_data/val_list.txt\"] transforms: ... - RecResizeImg: # Modify image_shape to fit long text image_shape: [3, 48, 320] ... loader: # Eval batch_size for Single card batch_size_per_card: 256 ... Note that the configuration file for prediction/evaluation must be consistent with the training.","title":"2.1 Start Training"},{"location":"training/recognition_paddleocr/#22-load-trained-model-and-continue-training","text":"If you expect to load trained model and continue the training again, you can specify the parameter Global.checkpoints as the model path to be loaded. For example: python3 tools/train.py -c configs/rec/rec_icdar15_train.yml -o Global.checkpoints = ./your/trained/model Note : The priority of Global.checkpoints is higher than that of Global.pretrained_model , that is, when two parameters are specified at the same time, the model specified by Global.checkpoints will be loaded first. If the model path specified by Global.checkpoints is wrong, the one specified by Global.pretrained_model will be loaded.","title":"2.2 Load Trained Model and Continue Training"},{"location":"training/recognition_paddleocr/#23-training-with-new-backbone","text":"The network part completes the construction of the network, and PaddleOCR divides the network into four parts, which are under ppocr/modeling . The data entering the network will pass through these four parts in sequence(transforms->backbones-> necks->heads). \u251c\u2500\u2500 architectures # Code for building network \u251c\u2500\u2500 transforms # Image Transformation Module \u251c\u2500\u2500 backbones # Feature extraction module \u251c\u2500\u2500 necks # Feature enhancement module \u2514\u2500\u2500 heads # Output module If the Backbone to be replaced has a corresponding implementation in PaddleOCR, you can directly modify the parameters in the Backbone part of the configuration yml file. However, if you want to use a new Backbone, an example of replacing the backbones is as follows: Create a new file under the ppocr/modeling/backbones folder, such as my_backbone.py. Add code in the my_backbone.py file, the sample code is as follows: import paddle import paddle.nn as nn import paddle.nn.functional as F class MyBackbone ( nn . Layer ): def __init__ ( self , * args , ** kwargs ): super ( MyBackbone , self ) . __init__ () # your init code self . conv = nn . xxxx def forward ( self , inputs ): # your network forward y = self . conv ( inputs ) return y Import the added module in the ppocr/modeling/backbones/_ init_ .py file. After adding the four-part modules of the network, you only need to configure them in the configuration file to use, such as: Backbone : name : MyBackbone args1 : args1 NOTE : More details about replace Backbone and other mudule can be found in doc .","title":"2.3 Training with New Backbone"},{"location":"training/recognition_paddleocr/#24-mixed-precision-training","text":"If you want to speed up your training further, you can use Auto Mixed Precision Training , taking a single machine and a single gpu as an example, the commands are as follows: python3 tools/train.py -c configs/rec/rec_icdar15_train.yml \\ -o Global.pretrained_model = ./pretrain_models/rec_mv3_none_bilstm_ctc_v2.0_train \\ Global.use_amp = True Global.scale_loss = 1024 .0 Global.use_dynamic_loss_scaling = True ``` <a name = \"25-distributed-training\" ></a> ### 2.5 Distributed Training During multi-machine multi-gpu training, use the ` --ips ` parameter to set the used machine IP address, and the ` --gpus ` parameter to set the used GPU ID: ``` bash python3 -m paddle.distributed.launch --ips = \"xx.xx.xx.xx,xx.xx.xx.xx\" --gpus '0,1,2,3' tools/train.py -c configs/rec/rec_icdar15_train.yml \\ -o Global.pretrained_model = ./pretrain_models/rec_mv3_none_bilstm_ctc_v2.0_train Note: (1) When using multi-machine and multi-gpu training, you need to replace the ips value in the above command with the address of your machine, and the machines need to be able to ping each other. (2) Training needs to be launched separately on multiple machines. The command to view the ip address of the machine is ifconfig . (3) For more details about the distributed training speedup ratio, please refer to Distributed Training Tutorial .","title":"2.4 Mixed Precision Training"},{"location":"training/recognition_paddleocr/#26-training-with-knowledge-distillation","text":"Knowledge distillation is supported in PaddleOCR for text recognition training process. For more details, please refer to doc .","title":"2.6 Training with Knowledge Distillation"},{"location":"training/recognition_paddleocr/#27-multi-language-training","text":"Currently, the multi-language algorithms supported by PaddleOCR are: Configuration file Algorithm name backbone trans seq pred language rec_chinese_cht_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc chinese traditional rec_en_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc English(Case sensitive) rec_french_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc French rec_ger_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc German rec_japan_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc Japanese rec_korean_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc Korean rec_latin_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc Latin rec_arabic_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc arabic rec_cyrillic_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc cyrillic rec_devanagari_lite_train.yml CRNN Mobilenet_v3 small 0.5 None BiLSTM ctc devanagari For more supported languages, please refer to : Multi-language model If you want to finetune on the basis of the existing model effect, please refer to the following instructions to modify the configuration file: Take rec_french_lite_train as an example: Global: ... # Add a custom dictionary, such as modify the dictionary, please point the path to the new dictionary character_dict_path: ./ppocr/utils/dict/french_dict.txt ... # Whether to recognize spaces use_space_char: True ... Train: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data/ # Path of train list label_file_list: [\"./train_data/french_train.txt\"] ... Eval: dataset: # Type of dataset\uff0cwe support LMDBDataSet and SimpleDataSet name: SimpleDataSet # Path of dataset data_dir: ./train_data # Path of eval list label_file_list: [\"./train_data/french_val.txt\"] ...","title":"2.7 Multi-language Training"},{"location":"training/recognition_paddleocr/#28-training-on-other-platformwindowsmacoslinux-dcu","text":"Windows GPU/CPU The Windows platform is slightly different from the Linux platform: Windows platform only supports single gpu training and inference, specify GPU for training set CUDA_VISIBLE_DEVICES=0 On the Windows platform, DataLoader only supports single-process mode, so you need to set num_workers to 0; macOS GPU mode is not supported, you need to set use_gpu to False in the configuration file, and the rest of the training evaluation prediction commands are exactly the same as Linux GPU. Linux DCU Running on a DCU device requires setting the environment variable export HIP_VISIBLE_DEVICES=0,1,2,3 , and the rest of the training and evaluation prediction commands are exactly the same as the Linux GPU.","title":"2.8 Training on other platform(Windows/macOS/Linux DCU)"},{"location":"training/recognition_paddleocr/#3-evaluation-and-test","text":"","title":"3. Evaluation and Test"},{"location":"training/recognition_paddleocr/#31-evaluation","text":"The model parameters during training are saved in the Global.save_model_dir directory by default. When evaluating indicators, you need to set Global.checkpoints to point to the saved parameter file. The evaluation dataset can be set by modifying the Eval.dataset.label_file_list field in the configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml file. # GPU evaluation, Global.checkpoints is the weight to be tested python3 -m paddle.distributed.launch --gpus '0' tools/eval.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.checkpoints={path/to/weights}/best_accuracy","title":"3.1 Evaluation"},{"location":"training/recognition_paddleocr/#32-test","text":"Using the model trained by paddleocr, you can quickly get prediction through the following script. The default prediction picture is stored in infer_img , and the trained weight is specified via -o Global.checkpoints : According to the save_model_dir and save_epoch_step fields set in the configuration file, the following parameters will be saved: output/rec/ \u251c\u2500\u2500 best_accuracy.pdopt \u251c\u2500\u2500 best_accuracy.pdparams \u251c\u2500\u2500 best_accuracy.states \u251c\u2500\u2500 config.yml \u251c\u2500\u2500 iter_epoch_3.pdopt \u251c\u2500\u2500 iter_epoch_3.pdparams \u251c\u2500\u2500 iter_epoch_3.states \u251c\u2500\u2500 latest.pdopt \u251c\u2500\u2500 latest.pdparams \u251c\u2500\u2500 latest.states \u2514\u2500\u2500 train.log Among them, best_accuracy. is the best model on the evaluation set; iter_epoch_x. is the model saved at intervals of save_epoch_step ; latest.* is the model of the last epoch. # Predict English results python3 tools/infer_rec.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model={path/to/weights}/best_accuracy Global.infer_img=doc/imgs_words/en/word_1.png Input image: Get the prediction result of the input image: infer_img: doc/imgs_words/en/word_1.png result: ('joint', 0.9998967) The configuration file used for prediction must be consistent with the training. For example, you completed the training of the Chinese model with python3 tools/train.py -c configs/rec/ch_ppocr_v2.0/rec_chinese_lite_train_v2.0.yml , you can use the following command to predict the Chinese model: # Predict Chinese results python3 tools/infer_rec.py -c configs/rec/ch_ppocr_v2.0/rec_chinese_lite_train_v2.0.yml -o Global.pretrained_model={path/to/weights}/best_accuracy Global.infer_img=doc/imgs_words/ch/word_1.jpg Input image: Get the prediction result of the input image: infer_img: doc/imgs_words/ch/word_1.jpg result: ('\u97e9\u56fd\u5c0f\u9986', 0.997218)","title":"3.2 Test"},{"location":"training/recognition_paddleocr/#4-inference","text":"The inference model (the model saved by paddle.jit.save ) is generally a solidified model saved after the model training is completed, and is mostly used to give prediction in deployment. The model saved during the training process is the checkpoints model, which saves the parameters of the model and is mostly used to resume training. Compared with the checkpoints model, the inference model will additionally save the structural information of the model. Therefore, it is easier to deploy because the model structure and model parameters are already solidified in the inference model file, and is suitable for integration with actual systems. The recognition model is converted to the inference model in the same way as the detection, as follows: # -c Set the training algorithm yml configuration file # -o Set optional parameters # Global.pretrained_model parameter Set the training model address to be converted without adding the file suffix .pdmodel, .pdopt or .pdparams. # Global.save_inference_dir Set the address where the converted model will be saved. python3 tools/export_model.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=en_PP-OCRv3_rec_train/best_accuracy Global.save_inference_dir=./inference/en_PP-OCRv3_rec/ If you have a model trained on your own dataset with a different dictionary file, please make sure that you modify the character_dict_path in the configuration file to your dictionary file path. After the conversion is successful, there are three files in the model save directory: inference/en_PP-OCRv3_rec/ \u251c\u2500\u2500 inference.pdiparams # The parameter file of recognition inference model \u251c\u2500\u2500 inference.pdiparams.info # The parameter information of recognition inference model, which can be ignored \u2514\u2500\u2500 inference.pdmodel # The program file of recognition model Text recognition model Inference using custom characters dictionary If the text dictionary is modified during training, when using the inference model to predict, you need to specify the dictionary path used by --rec_char_dict_path python3 tools/infer/predict_rec.py --image_dir=\"./doc/imgs_words_en/word_336.png\" --rec_model_dir=\"./your inference model\" --rec_image_shape=\"3, 32, 100\" --rec_char_dict_path=\"your text dict path\"","title":"4. Inference"},{"location":"training/recognition_paddleocr/#5-faq","text":"Q1: After the training model is transferred to the inference model, the prediction effect is inconsistent? A : There are many such problems, and the problems are mostly caused by inconsistent preprocessing and postprocessing parameters when the trained model predicts and the preprocessing and postprocessing parameters when the inference model predicts. You can compare whether there are differences in preprocessing, postprocessing, and prediction in the configuration files used for training.","title":"5. FAQ"},{"location":"training/recognition_paddleocr/#6-reference","text":"recognition_en.md training_en.md","title":"6. Reference:"},{"location":"training/training/","text":"","title":"Training"}]}